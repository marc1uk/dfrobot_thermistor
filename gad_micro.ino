// https://store-usa.arduino.cc/products/arduino-micro
// power can be provided either through USB, or via a 7-12V supply on Vin
//                                                    ^^^^^              
// power pins:
// VI: The input voltage to the MICRO board when it's using an external power source
// (as opposed to 5 volts from the USB connection or other regulated power source).
// 5V: The regulated power supply used to power the microcontroller and other components on the board.
// This can come either from VIN via an on-board regulator, or be supplied by USB or another regulated 5V supply.
// 3V: A 3.3 volt supply generated by the on-board regulator. Maximum current draw is 50 mA.
// digital i/o pins operate at 5 volts and can provide or receive 20 mA (DO NOT EXCEED 40mA).
// For receiving they have an internal pull-up resistor (disconnected by default) of 20-50 k ohm.

// I2C functions for controlling the Grove 4-channel relay
#include <multi_channel_relay.h>

// for blinking on-board LED
#define LONG_DELAY 100
#define SHORT_DELAY 10

// apparently we need to use digital pin numbers (or names)
// for PWM, even though we call 'analogWrite'
// https://forum.arduino.cc/t/someone-refresh-my-memory-on-how-pin-numbers-work/390682/6
// N.B. pin 12 is marked on the silkscreen as PWM, but it is not!
#define TUBE_FLOW_VALVES_PIN 10
#define PARALLEL_FLOW_VALVE_PIN 13

// for controlling the Deuterium/Tungsten lamp
// D18 = A0 on silkscreen
#define LAMP_DB15_ENABLE_PIN 18
// D19 = A1 on silkscreen
#define LAMP_SHUTTER_CONTROL_PIN 19
// D20 = A2 on silkscreen
#define LAMP_VIS_CONTROL_PIN 20
// D21 = A3 on silkscreen
#define LAMP_UV_CONTROL_PIN 21

// for controlling the FOS-2-INL inline shutters
#define GAD_ARM_SHUTTER_PIN 9
#define REF_ARM_SHUTTER_PIN 7
// we don't really need this tied to a pin per-se,
// but we have it there to keep the gnd on the same connector block
#define FOS_2_INL_GND_PIN 5

// we control the LED on/off states via an I2C controlled set of relays
// we don't really need to define these, but just to know that they're used
#define I2C_SCL_PIN 3
#define I2C_SDA_PIN 2
// they provide a library that defines a class to communicate with it
Multi_Channel_Relay relay;
bool grove_connected = false;
// define what's connected to each relay
#define LED275_CH 1
#define LEDW7E_CH 2

// for reading in the temperature of the LED
// D12 on silkscreen is A11
#define LED_TEMP_PIN 12
// FIXME we have two extra available analog pins that we could use
// to read temperatures from the valves. buuut... we have 3 valves,
// and the circuit would need modifying to provide current sources
// to convert the thermistor values to voltages. For now, these are unused.
// D22 = A4 on silkscreen
#define TV1_PIN 22
// D23 = A5 on silkscreen
#define TV2_PIN 23

// for reference, analogWrite is scaled 0-255
#define PWM_MAX 255
// while analogRead runs 0-1023
#define ANALOG_READ_MAX 1023

// PWM duty cycle for a 8V holding voltage based on 24V rail voltage
constexpr int VALVE_DEFAULT_DUTY_CYCLE = 100.*(8./24.);

// valves will be enabled first at full voltage (100% PWM duty cycle ~24V)
// then after some delay reduced to a 'holding' level (33% duty cycle ~8V)
// to reduce the heat dissipated by the valves and prevent over-heating.
constexpr int VALVE_DEFAULT_HOLDING_DELAY = 3000; // [ms]
int VALVE_HOLDING_DELAY = VALVE_DEFAULT_HOLDING_DELAY; // TODO add code to specify at runtime
// we'll also need to note when each valve was enabled to known when to switch to holding.
unsigned long tube_valves_opened = 0;
unsigned long parallel_valves_opened = 0;

const int verbosity=0;

void Blink(int ontime=LONG_DELAY, int nblinks=1){
	for(int i=0; i<nblinks; ++i){
		digitalWrite(LED_BUILTIN, HIGH);
		delay(ontime);
		digitalWrite(LED_BUILTIN, LOW);
	}
	return;
}

void openSerial(){
	
	Blink(SHORT_DELAY, 2);
	
	Serial.begin(19200);
	Serial.setTimeout(500);
	
	// wait for serial to connect
	while(!Serial){
		Blink(LONG_DELAY);
		delay(1000);
	}
	
	Blink(SHORT_DELAY, 4);
	
	/*
	// talk until we get a response
	while (Serial.available() <= 0) {
		Blink(LONG_DELAY);
		Serial.print('A');  // send a capital A
		delay(1000);
	}
	Serial.readString();  // read (and discard) the message
	Serial.println("Oh hello"); // reply hello
	*/
	
	return;
}

bool connectToGrove(){
	
	if(grove_connected) return true;
	
	// open comms to the grove multi-channel relay
	// Scan I2C to detect device
	Blink(SHORT_DELAY, 2);
	relay.begin(0x11);
	uint8_t relay_address = relay.scanI2CDevice();
	
	if((0x00 == relay_address) || (0xff == relay_address)){
		if(verbosity) Serial.println("failed to locate Grove multi-channel relay!");
		return false;
	} else {
		if(verbosity) Serial.println(String{"found grove on I2C address "}+relay_address);
		relay.begin(relay_address);
		if(verbosity) Serial.println("relay comms initialised");
		grove_connected = true;
	}
	Blink(SHORT_DELAY, 4);
	
	return true;
}

void setup() {
	
	// 2 short blinks - we're beginning setup
	Blink(SHORT_DELAY, 2);
	
	// setup the pins
	pinMode(LED_BUILTIN, OUTPUT);
	
	// n.b., although we call 'AnalogWrite' to output PWM,
	// the pin mode needs to be set to DIGITAL 
	pinMode(TUBE_FLOW_VALVES_PIN, OUTPUT);
	pinMode(PARALLEL_FLOW_VALVE_PIN, OUTPUT);
	
	pinMode(LAMP_DB15_ENABLE_PIN, OUTPUT);
	pinMode(LAMP_SHUTTER_CONTROL_PIN, OUTPUT);
	pinMode(LAMP_VIS_CONTROL_PIN, OUTPUT);
	pinMode(LAMP_UV_CONTROL_PIN, OUTPUT);
	
	pinMode(GAD_ARM_SHUTTER_PIN, OUTPUT);
	pinMode(REF_ARM_SHUTTER_PIN, OUTPUT);
	pinMode(FOS_2_INL_GND_PIN, OUTPUT);
	
	// set up temp monitoring pin as input
	pinMode(LED_TEMP_PIN, INPUT);
	
	// initialise all outputs to low... is this best?
	digitalWrite(LED_BUILTIN, LOW);
	digitalWrite(TUBE_FLOW_VALVES_PIN, LOW);
	digitalWrite(PARALLEL_FLOW_VALVE_PIN, LOW);
	digitalWrite(LAMP_DB15_ENABLE_PIN, LOW);
	digitalWrite(LAMP_SHUTTER_CONTROL_PIN, LOW);
	digitalWrite(LAMP_UV_CONTROL_PIN, LOW);
	digitalWrite(LAMP_VIS_CONTROL_PIN, LOW);
	digitalWrite(GAD_ARM_SHUTTER_PIN, LOW);
	digitalWrite(REF_ARM_SHUTTER_PIN, LOW);
	digitalWrite(FOS_2_INL_GND_PIN, LOW);
	
	openSerial();
	connectToGrove();
	
	Blink(SHORT_DELAY, 6);
	
	return;
}

void DoQuit(){
	Blink(LONG_DELAY, 5);
	// set all outputs to low
	digitalWrite(TUBE_FLOW_VALVES_PIN, LOW);
	digitalWrite(PARALLEL_FLOW_VALVE_PIN, LOW);
	
	digitalWrite(LAMP_DB15_ENABLE_PIN, LOW);
	digitalWrite(LAMP_SHUTTER_CONTROL_PIN, LOW);
	digitalWrite(LAMP_UV_CONTROL_PIN, LOW);
	digitalWrite(LAMP_VIS_CONTROL_PIN, LOW);
	
	switch_all_LEDs_off();
	
	tube_valves_opened = 0;
	parallel_valves_opened = 0;
	
	// close comms
	Serial.end();
	
	// sleep for 5 seconds
	delay(5000);
	
	// go back to waiting for serial connect
	openSerial();
	
	return;
}

void switch_LED(int RELAY_CH, bool on){
	if(on) relay.turn_on_channel(RELAY_CH);
	else relay.turn_off_channel(RELAY_CH);
	return;
}

void switch_all_LEDs_off(){
	// argument is a 4-bit mask
	relay.channelCtrl(0);
	return;
}

bool get_LED_state(int RELAY_CH){
	uint8_t channelstates = relay.getChannelState();
	return (channelstates & (1 << RELAY_CH));
	//return (1 & (channelstates >> RELAY_CH));
}

double GetLEDTemp(){
	// arduino micro provides 10-bit ADC resolution (1024) over a range 0-5V.
	// (this range can be reduced with the analogReference command to increase resolution;
	//  see https://www.arduino.cc/reference/en/language/functions/analog-io/analogreference/ )
	// MCP9701AT-E/LT has 19mV/C or 1 degree per bit for an 8-bit ADC
	// with output ranging 400mV-3V over 0-70 degrees (full range -40 -> 125C over ~0.25 -> 3.0V)
	// with +-2 degree accuracy without calibration
	// based on Eq 4.1 (datasheet p10) Vout = Tc*T+V0
	static const double V0 = 400.;  // mV
	static const double Tc = 19.5; // mV/C
	double Vsense = 1000.*double(analogRead(LED_TEMP_PIN))*(5./1024.);
	return (Vsense-V0)/Tc;
}

void switch_VALVE(int PIN, bool on){
	String state=(on ? "OPEN" : "CLOSED");
	String valve=(PIN==PARALLEL_FLOW_VALVE_PIN) ? "parallel" : "tube";
	if(verbosity) Serial.println("Setting "+valve+" flow to "+state);
	if(on) analogWrite(PIN, PWM_MAX);
	else analogWrite(PIN, 0);
	return;
}

void reduce_valve_to_holding(int PIN){
	int dutycycle = VALVE_DEFAULT_DUTY_CYCLE;
	// coerce to valid range
	if(dutycycle>100) dutycycle = 100;
	if(dutycycle<0) dutycycle = 0;
	String valve = (PIN==PARALLEL_FLOW_VALVE_PIN) ? "Parallel" : "Tube";
	if(verbosity) Serial.println("reducing "+valve+" voltage to holding duty cycle of "+dutycycle+"%");
	// convert to DAC counts
	int analogVal = (dutycycle/100.f) * PWM_MAX;
	// write
	analogWrite(PIN, analogVal);
	return;
}

void switch_TUBEVALVES(bool on, float dutycycle=VALVE_DEFAULT_DUTY_CYCLE){
	// n.b. the millis() function wraps after about 50 days, so is plenty long enough.
	if(on) tube_valves_opened = millis();
	else tube_valves_opened = 0;
	return switch_VALVE(TUBE_FLOW_VALVES_PIN, on);
}

void switch_PARALLELVALVE(bool on, float dutycycle=VALVE_DEFAULT_DUTY_CYCLE){
	if(on) parallel_valves_opened = millis();
	else parallel_valves_opened = 0;
	return switch_VALVE(PARALLEL_FLOW_VALVE_PIN, on);
}

void loop() {
	Blink();
	
	// check for a command on the serial port
	if(Serial.available()){
		Blink(SHORT_DELAY, 3);
		// read the command
		String command = Serial.readString(); // reads until timeout
		command.trim();  // trim leading and trailing whitespace
		
		// loop over pairs of key and value
		int pos = 0;
		while(command.length()){
			
			// get next key
			pos = command.indexOf(' ');
			if(verbosity) Serial.println(String("key pos ")+pos);
			String key = command.substring(0,pos);
			command = command.substring(pos+1); // if no end specified, until end of string
			command.trim();
			if(verbosity) Serial.println("GOT KEY '"+key+"', command is now '"+command+"'");
			
			// get next value
			String val("");
			if(command.length()){
				pos = command.indexOf(' ');
				if(verbosity) Serial.println(String("val pos ")+pos);
				if(pos>0){
					val = command.substring(0,pos);
					command = command.substring(pos+1);
					command.trim();
				} else {
					val = command;
					command = "";
				}
				if(verbosity) Serial.println("GOT VAL '"+val+"', command is now '"+command+"'");
			}
			
			// make uppercase
			key.toUpperCase(); // modifies string in-place
			
			// sort into two types of value syntax:
			// 'ON/OFF' or 'OPEN/CLOSED'
			// and get pin number for the former as it's simple
			int pin=-1;
			int type=-1;
			// type 0: ON/OFF via Relay
			if(key=="LED275"){
				type=0;
				pin=LED275_CH;
			} else if(key=="WHITE"){
				type=0;
				pin=LEDW7E_CH;
			}
			// type 1: ON/OFF via digitalWrite
			else if(key=="D2"){
				type=1;
				pin = LAMP_UV_CONTROL_PIN;
			}
			else if(key=="TUNGSTEN"){
				type=1;
				pin = LAMP_VIS_CONTROL_PIN;
			}
			// type 2: ENABLE/DISABLE
			else if(key=="LAMP"){
				// this doesn't actually turn the lamp on, but enables DB15 control...
				type=2;
				pin=LAMP_DB15_ENABLE_PIN;
			}
			// type 3: OPEN/CLOSE
			else if(key=="LAMP_SHUTTER"){
				type=3;
				pin = LAMP_SHUTTER_CONTROL_PIN;
			}
			else if(key=="GAD_ARM"){
				type=3;
				pin=GAD_ARM_SHUTTER_PIN;
			}
			else if(key=="REF_ARM"){
				type=3;
				pin=REF_ARM_SHUTTER_PIN;
			}
			else if(key=="TUBE" || key=="PARALLEL"){
				type=3;
			}
			else if(key=="Hello"){
				Serial.println("Hello!");
			}
			else if(key=="QUIT"){
				DoQuit();
				break;
			}
			else if(key=="GROVE"){
				if(connectToGrove()){
					Serial.println("OK");
				} else {
					Serial.println("Err: Could not connect to Grove relays");
				}
			}
			else if(key=="LED_TEMP"){
				double temp = GetLEDTemp();
				Serial.println(String{"LED Temp: "}+temp);
			}
			else {
				Serial.println("Err: Unknown command: '"+key+"'");
				pos = command.indexOf(' ');
				if(pos>0){
					command = command.substring(pos);
					command.trim();
				} else {
					command = "";
				}
			}
			
			Blink(LONG_DELAY, type);
			
			// parse, validate & enact command based on type
			if(type==0 || type==1){
				if(val!="ON" && val!="OFF"){
					Serial.println("Err: "+key+": Invalid value '"+val+"', use 'ON' or 'OFF'");
				} else {
					Serial.println("Setting "+key+" to "+val);
					if(type==0) switch_LED(pin, (val=="ON"));
					else digitalWrite(pin,(val=="ON"));
				}
			}
			
			else if(type==2){
				if(val!="ENABLE" && val!="DISABLE"){
					Serial.println("Err: "+key+": Invalid value '"+val+"', use 'ENABLE' or 'DISABLE'");
				} else {
					Serial.println("Setting "+key+" to "+val);
					digitalWrite(pin, (val=="ENABLE"));
				}
			}
			
			else if(type==3){
				if(val!="OPEN" && val!="CLOSE"){
					Serial.println("Err: "+key+": Invalid value '"+val+"', use 'OPEN' or 'CLOSE'");
				} else {
					Serial.println("Setting "+key+" to "+val);
					if(key=="TUBE"){
						// TODO add support for specifying duty cycle
						switch_TUBEVALVES(val=="OPEN");
					} else if(key=="PARALLEL"){
						switch_PARALLELVALVE(val=="OPEN");
					} else {
						// else a shutter
						digitalWrite(pin, (val=="OPEN"));
					}
				}
			}
			
		} // loop over key-value pairs
	} // else nothing on serial port
	
	// reduce valve voltages to holding if required
	if((tube_valves_opened>0) && ((millis()-tube_valves_opened)>VALVE_HOLDING_DELAY)){
		if(verbosity) Serial.println(String("tube valves open for ")+(millis()-tube_valves_opened)+" ms...");
		reduce_valve_to_holding(TUBE_FLOW_VALVES_PIN);
		tube_valves_opened = 0;
	}
	if((parallel_valves_opened>0) && ((millis()-parallel_valves_opened)>VALVE_HOLDING_DELAY)){
		if(verbosity) Serial.println(String("parallel valves open for ")+(millis()-parallel_valves_opened)+" ms...");
		reduce_valve_to_holding(PARALLEL_FLOW_VALVE_PIN);
		parallel_valves_opened = 0;
	}
	
	delay(1000);
	
	return;
}
